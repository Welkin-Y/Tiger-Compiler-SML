structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS

%nonterm  exp of A.exp | program of A.exp | vardec of A.dec | dec of A.dec | args of A.exp list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%nonassoc EQ NEQ LT LE GT GE
%left THEN ELSE
%left AND OR
%left EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS



%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program	: exp				(exp)

	
exp: 
NIL                 (A.NilExp)
| INT               (A.IntExp(INT))
| STRING            (A.StringExp(STRING, STRINGleft))
| ID LPAREN args RPAREN	(A.CallExp({func=Symbol.symbol(ID), args=args, pos=IDleft}))	(* f(args) *)
| ID LPAREN RPAREN	(A.CallExp({func=Symbol.symbol(ID), args=[], pos=IDleft}))		(* f() *)
| exp PLUS exp      (A.OpExp({left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left}))
| exp MINUS exp     (A.OpExp({left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left}))
| MINUS exp %prec UMINUS (A.OpExp({left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=exp1left}))
| exp TIMES exp     (A.OpExp({left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left}))
| exp DIVIDE exp    (A.OpExp({left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left}))
| exp EQ exp        (A.OpExp({left=exp1, oper=A.EqOp, right=exp2, pos=exp1left}))
| exp NEQ exp       (A.OpExp({left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left}))
| exp LT exp        (A.OpExp({left=exp1, oper=A.LtOp, right=exp2, pos=exp1left}))
| exp LE exp        (A.OpExp({left=exp1, oper=A.LeOp, right=exp2, pos=exp1left}))
| exp GT exp        (A.OpExp({left=exp1, oper=A.GtOp, right=exp2, pos=exp1left}))
| exp GE exp        (A.OpExp({left=exp1, oper=A.GeOp, right=exp2, pos=exp1left}))
| exp AND exp       (A.IfExp({test=exp1, then'=exp2, else'=NONE, pos=exp1left}))
| exp OR exp        (A.IfExp({test=exp1, then'=exp1, else'=SOME(exp2), pos=exp1left}))
| IF exp THEN exp   (A.IfExp({test=exp1, then'=exp2, else'=NONE, pos=exp1left}))
| IF exp THEN exp ELSE exp (A.IfExp({test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left}))


args: exp           (exp::nil)
| exp COMMA args    (exp::args)



